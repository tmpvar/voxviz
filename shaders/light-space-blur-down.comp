#version 430 core
#extension GL_NV_shader_buffer_load: enable
#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable

layout( local_size_x = 64, local_size_y = 4, local_size_z = 1 ) in;

uniform uint mipLevel;

#include "light-space-mips.glsl"

void main() {
  uint upperMip = mipLevel + 1;
  // lower mip cell size
  float cellSize = (float(1<<(mipLevel)));

  // get the world space position
  vec3 pos = gl_GlobalInvocationID.xyz * cellSize;


  if (any(greaterThanEqual(pos, lightSlabDims))) {
    return;
  }

  vec4 acc = vec4(0.0);
  vec4 tmp;
  float ls = 1.0;
  accumulate(pos + vec3( 0.0,  0.0, 0.0), upperMip, 0.125, acc);
  accumulate(pos + vec3( 0.0,  0.0, 0.0), upperMip, 1.0, acc);
  accumulate(pos + vec3(  ls,  0.0, 0.0), upperMip, 0.125, acc);
  accumulate(pos + vec3( -ls,  0.0, 0.0), upperMip, 0.125, acc);
  accumulate(pos + vec3( 0.0,  ls,  0.0), upperMip, 0.125, acc);
  accumulate(pos + vec3( 0.0, -ls,  0.0), upperMip, 0.125, acc);
  accumulate(pos + vec3( 0.0,  0.0,  ls), upperMip, 0.125, acc);
  accumulate(pos + vec3( 0.0,  0.0, -ls), upperMip, 0.125, acc);

  // accumulate(pos + vec3( 0.0,  0.0, 0.0), mipLevel, 1.0, acc);
  // accumulate(pos + vec3(  ls,  0.0, 0.0), mipLevel, 0.25, acc);
  // accumulate(pos + vec3( -ls,  0.0, 0.0), mipLevel, 0.25, acc);
  // accumulate(pos + vec3( 0.0,  ls,  0.0), mipLevel, 0.25, acc);
  // accumulate(pos + vec3( 0.0, -ls,  0.0), mipLevel, 0.25, acc);
  // accumulate(pos + vec3( 0.0, 0.0,  ls), mipLevel, 0.25, acc);
  // accumulate(pos + vec3( 0.0, 0.0, -ls), mipLevel, 0.25, acc);

  accumulate(pos + vec3( ls, 0.0,  ls),  mipLevel, 0.125, acc);
  accumulate(pos + vec3(-ls, 0.0,  ls),  mipLevel, 0.125, acc);
  accumulate(pos + vec3(-ls, 0.0, -ls),  mipLevel, 0.125, acc);
  accumulate(pos + vec3(-ls, 0.0,  ls),  mipLevel, 0.125, acc);
  accumulate(pos + vec3( ls,  ls, 0.0),  mipLevel, 0.125, acc);
  accumulate(pos + vec3(-ls,  ls, 0.0),  mipLevel, 0.125, acc);
  accumulate(pos + vec3(-ls, -ls, 0.0),  mipLevel, 0.125, acc);
  accumulate(pos + vec3( ls, -ls, 0.0),  mipLevel, 0.125, acc);
  accumulate(pos + vec3( 0.0,  ls,  ls), mipLevel, 0.125, acc);
  accumulate(pos + vec3( 0.0, -ls,  ls), mipLevel, 0.125, acc);
  accumulate(pos + vec3( 0.0, -ls, -ls), mipLevel, 0.125, acc);
  accumulate(pos + vec3( 0.0,  ls, -ls), mipLevel, 0.125, acc);
  accumulate(pos + vec3(  ls,  ls,  ls), mipLevel, 0.125, acc);
  accumulate(pos + vec3( -ls,  ls,  ls), mipLevel, 0.125, acc);
  accumulate(pos + vec3( -ls, -ls,  ls), mipLevel, 0.125, acc);
  accumulate(pos + vec3( -ls, -ls, -ls), mipLevel, 0.125, acc);
  accumulate(pos + vec3( -ls,  ls, -ls), mipLevel, 0.125, acc);
  accumulate(pos + vec3(  ls,  ls, -ls), mipLevel, 0.125, acc);
  accumulate(pos + vec3(  ls, -ls, -ls), mipLevel, 0.125, acc);


  // light_mip_get(pos, upperMip, tmp);
  // acc += tmp / 2.0;
  // light_mip_get(pos, mipLevel, tmp);
  // acc += tmp;

  acc /= 4.0;



  light_mip_set(pos, mipLevel, acc);
}
