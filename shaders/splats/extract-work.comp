#version 430 core
#extension GL_NV_shader_buffer_load: enable
#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable
#extension GL_ARB_shader_ballot: enable
#extension GL_NV_shader_thread_group : require
#extension GL_NV_shader_thread_shuffle : require

layout( local_size_x = 2, local_size_y = 2, local_size_z = 2 ) in;

#include "../voxel-space-mips.glsl"
#include "../splats.glsl"
#include "../palette.glsl"
#include "../morton.glsl"
#include "../hsl.glsl"

// brings in read() and visible()
#include "util.glsl"

uniform uint mipLevel;

layout (std430) buffer splatIndirectRenderBuffer {
  DrawArraysIndirectCommand indirectRender;
};

layout (std430) buffer nextSplatIndirectComputeBuffer {
  DispatchIndirectCommand nextIndirectCompute;
};

layout (std430) buffer splatInstanceBuffer {
  Splat splats[];
};

layout (std430) buffer prevSplatInstanceBuffer {
  Splat prevSplats[];
};

shared uint slots;

void main() {
  uint prevSplatIdx = gl_WorkGroupID.x;
  uvec3 localPos = gl_LocalInvocationID.xyz;

  uint idx = uint(gl_GlobalInvocationID.x);

  vec3 prevSplatPos = prevSplats[prevSplatIdx].position.xyz;
  vec3 worldPos = prevSplatPos + vec3(localPos * (1<<mipLevel));

  uint8_t palette_idx;
  if (
    !voxel_mip_get(worldPos, mipLevel, palette_idx) ||
    !visible(vec3(worldPos), mipLevel)
  ) {
    return;
  }

  uint splatIdx = atomicAdd(indirectRender.count, 1);

  if (mipLevel > 0) {
    atomicAdd(nextIndirectCompute.num_groups_x, 1);
  }

  Splat entry;
  entry.position = vec4(worldPos, float(mipLevel+1));
  entry.color = vec4(
    hsl(vec3(float(mipLevel)/float(MAX_MIP_LEVELS + 1) * 0.99, 0.9, 0.45)),
    1.0
  );
  entry.color = vec4(palette_color(palette_idx), 1);

  splats[splatIdx] = entry;
}
