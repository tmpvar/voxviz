#version 430 core

#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable
#extension GL_ARB_gpu_shader_int64 : enable
#extension GL_NV_shader_atomic_int64 : enable

layout( local_size_x = 32 ) in;

#include "../splats.glsl"
#include "../shared/quadric-proj.glsl"
#include "../hsl.glsl"

layout (std430) buffer splatInstanceBuffer {
  Splat splats[];
};

layout (std430) buffer pixelBuffer {
  uint64_t pixel[];
};

uniform uvec2 resolution;
uniform mat4 mvp;
uniform vec3 eye;

int get_pixel_pos(ivec2 p, ivec2 d) {
  return int(mix(
    p.x + p.y * d.x,
    -1,
    any(lessThan(p, ivec2(0))) || any(greaterThanEqual(p, d))
  ));
}

void main() {
  uint splat_idx = gl_GlobalInvocationID.x;
  Splat splat = splats[splat_idx];
  vec3 n = normalize(splat.normal.xyz);

  if (dot((splat.position.xyz - eye), n) >= 0) {
    return;
  }

  vec4 uv_pos = mvp * vec4(splat.position.xyz, 1.0);
  uv_pos.xyz = uv_pos.xyz / uv_pos.w;
  if (
    uv_pos.w <= 0.0 ||
    uv_pos.x < -1.0 ||
    uv_pos.x > 1.0 ||
    uv_pos.y < -1.0 ||
    uv_pos.y > 1.0
  ) {
		return;
	}

  uv_pos.xy = (uv_pos.xy * 0.5 + 0.5) * vec2(resolution);

  int pixel_idx = get_pixel_pos(ivec2(uv_pos.xy), ivec2(resolution));
  if (pixel_idx < 0) {
    return;
  }

  double uv_depth = uv_pos.w;
  int64_t pixel_depth = 0;//int64_t(uv_depth * 1000000.0lf);

  uint64_t color = 0;

  color |= uint64_t(n.x * 255.0) << 16;
  color |= uint64_t(n.y * 255.0) << 8;
  color |= uint64_t(n.z * 255.0) << 0;

  uint64_t pixel_value = (pixel_depth << 24) | color;

	atomicMin(pixel[uint(pixel_idx)], pixel_value);
}
