#version 430 core
#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable

#include "voxel.glsl"

uniform uint *stockBuffer;
uniform uint *toolBuffer;
uniform vec3 toolBrickIndex;
uniform vec3 stockBrickIndex;
uniform mat4 stockToTool;
uniform vec3 toolBrickVerts[8];

// TODO: how do we cut transformed bricks?
// TODO: how do we cut using transformed bricks?

// TODO: use variable group size so we can better control the
//       slice size
layout( local_size_x = 16, local_size_y = 1, local_size_z = 1 ) in;

vec3 tx(mat4 m, vec3 v) {
  vec4 tmp = m * vec4(v, 1.0);
  return tmp.xyz / tmp.w;
}

void main() {
	uint idx = gl_GlobalInvocationID.x;
	uint lower = idx * VOXEL_WORD_BITS;
	uint upper = lower + VOXEL_WORD_BITS;

	for (uint p = lower; p < upper; p++) {
		uint mask = 1 << (p - lower);
		vec3 stockVoxel = vec3(
			p % BRICK_DIAMETER,
			(p / BRICK_DIAMETER) % BRICK_DIAMETER,
			((p / BRICK_DIAMETER) / BRICK_DIAMETER) % BRICK_DIAMETER
		);

		vec3 localPos = stockBrickIndex + (vec3(stockVoxel) + 0.5) * INV_BRICK_DIAMETER;
		// transform the point back into tool space
		vec3 v2 = tx(stockToTool, localPos);
		ivec3 toolVoxel = ivec3(floor((v2 - toolBrickIndex) * BRICK_DIAMETER));
		stockBuffer[idx] |= voxel_get(toolBuffer, toolVoxel) ? mask : 0;
	}
}
