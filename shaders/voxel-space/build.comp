#version 430 core
#extension GL_NV_shader_buffer_load: enable
#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable

layout( local_size_x = 4, local_size_y = 4, local_size_z = 4 ) in;

layout (std430) buffer worldSpaceVoxelBuffer {
  uint8_t world_voxels[];
};

layout (std430) buffer modelSpaceVoxelBuffer {
  uint8_t model_voxels[];
};

layout (std430) buffer lightIndexBuffer {
  uint current_light_index;
};

struct Light {
  vec4 position;
  vec4 color;
};

layout (std430) buffer lightBuffer {
  Light lights[];
};

uniform uvec3 worldSpaceDims;
uniform uvec3 modelSpaceDims;
uniform mat4 model;

void fill(vec3 pos) {
  vec4 hpos = model * vec4(pos + vec3(0.5), 1.0);
  vec3 write_pos = hpos.xyz / hpos.w;

  if (
    any(lessThan(write_pos, vec3(0.0))) ||
    any(greaterThanEqual(write_pos, vec3(worldSpaceDims)))
  ) {
    return;
  }

  uvec3 wp = uvec3(write_pos);

  uint write_idx = (
    wp.x +
    wp.y * worldSpaceDims.x +
    wp.z * worldSpaceDims.x * worldSpaceDims.y
  );

  world_voxels[write_idx] = uint8_t(1);

}

void main() {
  uvec3 pos = gl_GlobalInvocationID.xyz;

  uint read_idx = (
    pos.x +
    pos.y * modelSpaceDims.x +
    pos.z * modelSpaceDims.x * modelSpaceDims.y
  );

  uint8_t model_value = model_voxels[read_idx];

  if (
    any(greaterThanEqual(pos, modelSpaceDims)) ||
    model_value == uint8_t(0)
  ) {
    return;
  }


  if (model_value == uint8_t(8)) {
    uint light_idx = atomicAdd(current_light_index, 1);
    vec4 hpos = model * vec4(pos + vec3(0.5), 1.0);
    vec3 write_pos = hpos.xyz / hpos.w;

    lights[light_idx].position = vec4(write_pos, 1.0);
    lights[light_idx].color = vec4(1.0);
  }

  vec3 fpos = vec3(pos);
  fill(fpos);
  float f = 0.25;
  fill(fpos + vec3(  -f, 0.0, -f));
  fill(fpos + vec3(   f, 0.0, -f));
  fill(fpos + vec3( 0.0,  -f, -f));
  fill(fpos + vec3(   f,   f, -f));

  fill(fpos + vec3(  -f, 0.0, f));
  fill(fpos + vec3(   f, 0.0, f));
  fill(fpos + vec3( 0.0,  -f, f));
  fill(fpos + vec3(   f,   f, f));
}
