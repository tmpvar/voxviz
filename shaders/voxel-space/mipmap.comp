#version 430 core
#extension GL_NV_shader_buffer_load: enable
#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable

layout( local_size_x = 8, local_size_y = 4, local_size_z = 1 ) in;

uniform uvec3 mipDims;
uniform uvec3 lowerMipDims;
uniform uint mipLevel;

#include "../voxel-space-mips.glsl"

uniform layout(r8) image3D worldSpaceVoxelImage;
uniform sampler3D worldSpaceVoxelTextureLower;

float read(ivec3 pos) {
  uvec3 p = pos << 1;

  if (any(lessThan(p, ivec3(0))) || any(greaterThanEqual(p, lowerMipDims))) {
    return 0;
  }

  return textureLod(
    worldSpaceVoxelTextureLower,
    vec3(p) / vec3(lowerMipDims),
    float(mipLevel-1)
  ).x;
}

void main() {
  ivec3 pos = ivec3(gl_GlobalInvocationID.xyz);
  if (any(greaterThanEqual(pos, mipDims))) {
    return;
  }

  float width = 3;
  float l = floor(width/2.0);
  float sigma = 2.1;


  float pi = 3.1459;


  float density = 0.0;//read(pos);
  float count = 1;
  if (false) {
    density += read(pos + ivec3(0, 0, 0));
    density += read(pos + ivec3(1, 0, 0));
    density += read(pos + ivec3(1, 1, 0));
    density += read(pos + ivec3(0, 1, 0));
    density += read(pos + ivec3(0, 0, 1));
    density += read(pos + ivec3(1, 0, 1));
    density += read(pos + ivec3(1, 1, 1));
    density += read(pos + ivec3(0, 1, 1));
    count = 8.0;
  } else {
    //
    count = 20;
    for (float x = -l; x <= l; x++) {
      for (float y = -l; y <= l; y++) {
        for (float z = -l; z <= l; z++) {
          //density += read(pos + ivec3(x,y,z));

          //float c = (sigma - length(vec3(x, y, z))) / 17.173030;
          // sigma = 2.75;
          // float c = exp(
          //   -2 * pi * pi *
          //   (pow(x,2) * sigma + pow(y, 2) * sigma + pow(z, 2) * sigma)
          // );
          // density += read(pos + ivec3(x, y, z)) * c;
          density += read(pos + ivec3(x, y, z));

        }
      }
    }
  }

  imageStore(
    worldSpaceVoxelImage,
    ivec3(pos),
    vec4(density / count)
  ).x;
}
