#version 430 core
#extension GL_NV_shader_buffer_load: enable
#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable

layout( local_size_x = 8, local_size_y = 4 ) in;

#include "../ray-aabb.glsl"
#include "../voxel-space.glsl"
#include "../hsl.glsl"
#include "../voxel-space-mips.glsl"

layout (std430) buffer lightIndexBuffer {
  uint current_light_index;
};

struct Light {
  vec4 position;
  vec4 color;
};

layout (std430) buffer lightBuffer {
  Light lights[];
};

layout (std430) buffer blueNoiseBuffer {
  vec4 blueNoise[];
};

layout (std430) buffer colorBuffer {
  vec4 colors[];
};

uniform uint time;

#include "../cdir.glsl"

uniform uvec2 resolution;

uniform sampler2D gBufferPosition;
uniform sampler2D gBufferColor;
uniform sampler2D gBufferDepth;
uniform sampler2D gBufferNormal;
uniform sampler3D worldSpaceVoxelTexture;

uniform mat4 VP;

#define ITERATIONS 128

bool oob(vec3 p) {
  if (
    any(lessThan(p, vec3(0.0))) ||
    any(greaterThanEqual(p, vec3(volumeSlabDims)))
  ) {
    return true;
  }
  return false;
}

float read(vec3 pos, float mip) {
  float value = textureLod(
    worldSpaceVoxelTexture,
    pos/vec3(volumeSlabDims),
    mip
  ).x;

  return value;
}

#define VOXEL_SIZE 1
#include "trace.glsl"


// lifted from https://github.com/armory3d/armory/blob/master/Shaders/std/conetrace.glsl
uint traceLight(vec3 pos, vec3 light_pos, vec3 light_col, inout vec3 acc, vec3 normal) {
   vec3 d = normalize(light_pos - pos);


  float sampleCol = 0.0;
  float dist = 0.0;
  float aperture = 2.0 / tan(45 / 3.1459);
  float diam = dist * aperture;
  vec3 samplePos = d * dist + pos;
  float maxDist = distance(light_pos, pos);
  float occ = 0.0;
  while (occ < 1.0 && dist < maxDist) {
    float mip = max(log2(diam/2), 0);
    // float mipSample = read(samplePos * 0.5 + vec3(0.5), mip).r;
    float mipSample = read(samplePos, mip).r * 0.5 ;
    occ += (mipSample) / (1.0 + 0.3 * diam);
    sampleCol += (1 - sampleCol) * mipSample;
    dist += max(diam / 2, VOXEL_SIZE);
    //diam = dist * aperture;
    diam = max(1, 2.0 * aperture * dist);
    samplePos = d * dist + pos;
  }
  //acc += (light_col * 1.0/sampleCol);//* (1.0 - sampleCol);
  acc += light_col * occ;
  // acc += vec3(1.0 - occ);
  return 1;//1.0 - occ;
}

uint traceLight0(vec3 pos, vec3 light_pos, vec3 light_col, inout vec3 acc, vec3 normal) {
	float occ = 0;
  // if (abs(dot(light_pos - pos, -normal)) < 0.5) {
    pos -= normal * 4.0;
  // }
  vec3 d = normalize(light_pos - pos);
  float t = -1.0;//5.0+dot(-d, normal);
  bool foundSafe = false;

  float aperture = 2.0 / tan(45 / 3.1459);
  float diam = t * aperture;

  vec3 p = pos;
  uint8_t val;
  const float STOP = 128;
  float distance_to_light = distance(pos, light_pos);
  d = normalize(light_pos - p);
  float mip = 0.0;
	while(t < distance_to_light && occ < 1.0) {
    if (oob(p)) {
      return 0;
    }

    float l = pow(t, 2); // Experimenting with inverse square falloff for shadows.
    // t += 0.9 * (1 + 0.05 * l);
    t += max(diam / 2, VOXEL_SIZE);
    //diam = dist * aperture;
    diam = max(1, aperture * t);
		//t += max(0.1, t*0.0125);//0.9 * (1 + 0.05 * l);
    //mip = min(4, t/120);// 2/tan(45/3.1459);//min(MAX_MIPS, uint(floor(t/ITERATIONS * MAX_MIPS)));
    p = pos + d * t;

    float current_distance_to_light = distance(p, light_pos);
    if (current_distance_to_light < 1.0) {
      acc += light_col * (1 - pow(smoothstep(0, 1, occ * 1.4), 1.0 / 1.4));
      return 1;
    }

    mip = max(log2(diam/2), 0);
    occ += (1.0 - occ) * read(p, diam);
	}

  return 0;
}

uint traceLight1(vec3 pos, vec3 light_pos, vec3 light_col, inout vec3 acc, vec3 normal) {
  vec3 d = normalize(light_pos - pos);
  vec3 id = 1.0 / d;
  vec3 p = pos;// + d * found_distance;

  float dt = 1.0 / length(volumeSlabDims);
  float t = 4.0;
  float opacityDiv = 1.0 / 8.0;

  int minMip = 0;
  int maxMip = MAX_MIPS;
  int mip = 0;
  float mipSize = (float(1<<(mip)));
  float invMipSize = 1.0 / mipSize;
  vec3 mask;
  bool miss = true;
  bool isOut = false;
  uint8_t palette_idx;
  p = pos + d * t;
  int i;
  // for (i=0; !isOut && i<10; i++) {
  //   if (
  //     any(lessThan(p, vec3(0.0))) ||
  //     any(greaterThanEqual(p, vec3(volumeSlabDims)))
  //   ) {
  //     break;
  //   }
  //
  //   if (!isOut && !voxel_mip_get(p, 0, palette_idx)) {
  //     isOut = true;
  //   }
  //
  //   vec3 deltas = (step(0.0, d) - fract(p * invMipSize)) * id;
  //   dt = max(mincomp(deltas), 0.0001) * mipSize;
  //   t += dt;
  //   p = pos + d * t;
  // }


  for (i=0; i<ITERATIONS; i++) {
    if (
      any(lessThan(p, vec3(0.0))) ||
      any(greaterThanEqual(p, vec3(volumeSlabDims)))
    ) {
      break;
    }

    float distance_to_light = distance(p, light_pos);
    if (distance_to_light < 4) {
      acc += light_col * distance_to_light / 4.0;// * (1.0 - float(mipSize)/float(1<<MAX_MIPS));
      return 1;
    }

    if (voxel_mip_get(p, mip, palette_idx)) {
      if (mip == minMip) {
        return 0;
      }
      // } else {
      //   light_col -= float(mip)/float(MAX_MIPS);
      // }

      mip = max(mip - 1, minMip);
      t -= dt * 0.00125;

      mipSize = (float(1<<(mip)));
      invMipSize = 1.0 / mipSize;
      continue;
    } else if (mip < maxMip && !voxel_mip_get(p, min(mip + 1, maxMip), palette_idx)) {
      mip = min(maxMip, mip+1);
      mipSize = (float(1<<(mip)));
      invMipSize = 1.0 / mipSize;
      t += dt * 0.00125;
    }
    vec3 deltas = (step(0.0, d) - fract(p * invMipSize)) * id;
    dt = max(mincomp(deltas), 0.0001) * mipSize;
    t += dt;
    // FIXME: we get ~1ms back if this is enabled, but lose the ability to
    //        compute good face normals. There is likely a better mechanism
    //        for increasing marching speed at further distances (cone marching?)
    //t += max(0.1,t/1024);
    p = pos + d * t;
  }

  return 0;
}

//vec4 trace_mine(vec3 pos, vec3 dir) {


uint traceLight2(vec3 pos, vec3 light_pos, vec3 light_col, inout vec3 acc, vec3 normal) {
  uint8_t palette_idx;

  // TODO: now that we have the normal we can do a blank dda step out past the
  // model transformed normal to the next integer location.. to avoid stepping
  // through the course voxelization and immediately terminating.
  //pos += normal * 2.0;
  vec3 d = normalize(light_pos - pos);
  vec3 id = 1.0 / d;
  vec3 p = pos;

  float dt = 1.0 / length(volumeSlabDims);
  float t = 0.0;

  int minMip = 0;
  int maxMip = 0;
  int mip = minMip;
  float mipSize = (float(1<<(mip)));
  float invMipSize = 1.0 / mipSize;

  vec3 deltas = (step(0.0, d) - fract(p * invMipSize)) * id;
  // dt = max(mincomp(deltas), 0.1) * mipSize;
  // t += dt;


  // vec3 mask;
  // bool miss = true;
  uint hit_count = 0;
  for (int i=0; i<ITERATIONS && hit_count < 1 ; i++) {
    float distance_to_light = distance(p, light_pos);
    if (distance_to_light < 4.0) {
      acc += light_col;// * distance_to_light / 4.0;// * (1.0 - float(mipSize)/float(1<<MAX_MIPS));
      return 1;
    }

    if (voxel_mip_get(p, mip, palette_idx)) {
      hit_count++;
    } else {
      hit_count = 0;
    }

    deltas = (step(0.0, d) - fract(p * invMipSize)) * id;
    dt = max(mincomp(deltas), 0.01) * mipSize;
    //t += dt;// * 1.1;
    //t += max(0.2, t * 0.1);
    t+=dt * 2.0;

    p = pos + d * t;
  }
  return 0;
}

void main() {
  ivec2 tx = ivec2(gl_GlobalInvocationID.xy);
  uint color_idx = (
    uint(tx.x) +
    uint(tx.y) * resolution.x
  );

  colors[color_idx] = vec4(0.0);
  float depth = texelFetch(gBufferDepth, tx, 0).x;
  vec3 normal = (texelFetch(gBufferNormal, tx, 0).xyz - 0.5) * 2.0;
  vec4 color = texelFetch(gBufferColor, tx, 0);
  vec3 pos = texelFetch(gBufferPosition, tx, 0).xyz * vec3(volumeSlabDims);

  if (oob(pos)) {
    return;
  }

  if (depth >= 1.0) {
    return;
  }

  vec3 acc = vec3(0.0);
  uint total_lights = min(current_light_index, 128);
  uint contribs = 1;
  for (uint i=0; i<total_lights; i++) {

    vec3 light_pos = lights[i].position.xyz;
    vec3 light_col = hsl(vec3(0.7 - (float(i)/float(total_lights) * 0.9), 0.9, 0.5)); //light.color.rgb;

    if (distance(pos, light_pos) < 2) {
      colors[color_idx] = vec4(light_col, 0.0);
      return;
    }

    if (distance(pos, light_pos) > ITERATIONS) {
      continue;
    }

    if (dot((light_pos - pos), normal) >= 0) {
      continue;
    }

    vec3 d = normalize(light_pos - pos);
    vec3 p = pos;

    vec3 pp = (blueNoise[((i+1) * color_idx + time * 1000) % (4096 * 64) ].xyz * 2.0 - 1);
    vec3 pp2 = (blueNoise[((i+2) * color_idx + time * 1000) % (4096 * 64) ].xyz);
    light_pos += pp2 * 2.0;

    float t;
    // bool safe = false;
    // for (t=0; t<8; t+=0.01) {
    //   if (oob(p)) {
    //     break;
    //   }
    //
    //   if (read(p, 0) == 0.0) {
    //     safe = true;
    //     break;
    //   }
    //   p = pos + d * t;
    // }
    //
    // if (!safe) {
    //   continue;
    // }

    // contribs += traceLight0(p, light_pos, light_col, acc, normal);
    float intensity = traceMine(p + normal * pp * 2.0, light_pos);
    acc += intensity * light_col;
  }

  acc /= float(contribs);

  colors[color_idx] = vec4(acc, 1.0);// * color;
}
