#version 430 core
#extension GL_NV_shader_buffer_load: enable
#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable

layout( local_size_x = 32, local_size_y = 16, local_size_z = 1 ) in;

#include "voxel-space-mips.glsl"
#include "splats.glsl"
#include "palette.glsl"
#include "morton.glsl"


layout (std430) buffer splatIndirectCommandBuffer {
  DrawArraysIndirectCommand command;
};

layout (std430) buffer splatInstanceBuffer {
  Splat splats[];
};

writeonly layout (std430) buffer splatBucketBuffer {
  SplatBucket buckets[];
};

int read(vec3 p) {
  if (any(lessThan(p, vec3(0.0))) || any(greaterThanEqual(p, volumeSlabDims))) {
      return 0;
  }
  uint8_t nop;
  return voxel_mip_get(p, 0, nop) ? 1 : 0;
}

void main() {
  // walk the octree and find edge voxels
  // for each edge voxel:
  // - add its position to a buffer
  // - increment an atomic counter command.primCount
  vec3 p = vec3(gl_GlobalInvocationID.xyz);

  uint8_t palette_idx;

  if (!voxel_mip_get(p, 0, palette_idx)) {
    return;
  }

  int a = 0;
  a+=read(p + vec3(1.0, 0.0, 0.0));
  a+=read(p + vec3(-1.0, 0.0, 0.0));

  a+=read(p + vec3(0.0, 1.0, 0.0));
  a+=read(p + vec3(0.0, -1.0, 0.0));

  a+=read(p + vec3(0.0, 0.0, 1.0));
  a+=read(p + vec3(0.0, 0.0, -1.0));

  //if (a < 6) {
    uint code = EncodeMorton3(uvec3(p));
    uint bucketIdx = code >> SPLAT_BUCKET_SIZE_SHIFT;
    // uint splatIdx = code & SPLAT_BUCKET_SIZE_SHIFT;
    //atomicAdd(command.primCount, 1);
    uint splatIdx = atomicAdd(buckets[bucketIdx].loc, 1);
    Splat entry;
    entry.position = vec4(p, 1.0);
    entry.color = vec4(palette_color(palette_idx), 1.0);

    buckets[bucketIdx].splats[splatIdx] = entry;
  //}
}
