#version 430 core
#extension GL_NV_shader_buffer_load: enable
#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable
#extension GL_ARB_shader_ballot: enable
#extension GL_NV_shader_thread_group : require
#extension GL_NV_shader_thread_shuffle : require

layout( local_size_x = 64, local_size_y = 16, local_size_z = 1 ) in;

#include "voxel-space-mips.glsl"
#include "splats.glsl"
#include "palette.glsl"
#include "morton.glsl"
#include "hsl.glsl"

#define miplevel 2

layout (std430) buffer splatIndirectCommandBuffer {
  DrawArraysIndirectCommand command;
};

layout (std430) buffer splatInstanceBuffer {
  Splat splats[];
};

layout (std430) buffer splatBucketBuffer {
  SplatBucket buckets[];
};

layout (std430) buffer splatScratchBuffer {
  uint8_t scratch[];
};

uint read(vec3 p) {
  p *= (miplevel + 1);
  if (any(lessThan(p, vec3(0.0))) || any(greaterThan(p, volumeSlabDims))) {
      return 0;
  }
  uint8_t nop;
  return voxel_mip_get(p, miplevel, nop) ? 1 : 0;
}

// ported from https://devblogs.nvidia.com/cuda-pro-tip-optimized-filtering-warp-aggregated-atomics/
uint atomicAggInc(uint *ctr) {

  uint active_threads = activeThreadsNV();
  int leader = findLSB(active_threads);
  int change = bitCount(active_threads);
  //uint rank = bitCount(active & __lanemask_lt());
  uint rank = gl_ThreadInWarpNV;
  uint warp_res;
  if(rank == 0) {
    warp_res = atomicAdd(ctr, change);
  }
  //warp_res = __shfl_sync(active, warp_res, leader);
  bool nop;
  warp_res = shuffleNV(warp_res, active_threads, 32, nop);
  return warp_res + rank;
}

bool visible(vec3 p) {
  uint a = 1;

  a &= read(p + vec3(1.0, 0.0, 0.0));
  a &= read(p + vec3(-1.0, 0.0, 0.0));

  a &= read(p + vec3(0.0, 1.0, 0.0));
  a &= read(p + vec3(0.0, -1.0, 0.0));

  a &= read(p + vec3(0.0, 0.0, 1.0));
  a &= read(p + vec3(0.0, 0.0, -1.0));

  return a == 0;
}

shared uint slots;

void main() {
  uint8_t palette_idx;
  uvec3 gridPos = uvec3(gl_GlobalInvocationID.xyz);
  uvec3 worldPos = gl_GlobalInvocationID.xyz * (miplevel + 1);
  vec3 p = vec3(worldPos);

  if (any(greaterThan(worldPos, volumeSlabDims))) {
    return;
  }

  if (!voxel_mip_get(p, miplevel, palette_idx)) {
    return;
  }

  if (!visible(vec3(gridPos))) {
    // uint splatIdx = atomicAdd(command.count, 1);
    // Splat entry;
    // entry.position = vec4(p, 1.0);
    // entry.color = vec4(0.0, 1.0, 0.0, 1.0);
    // splats[splatIdx] = entry;
    return;
  }

  uint splatIdx = atomicAdd(command.count, 1);
  Splat entry;
  entry.position = vec4(p,  1.0);
  entry.color = vec4(palette_color(palette_idx), float(miplevel + 1));
  splats[splatIdx] = entry;
}

void main1() {
  uint8_t palette_idx;
  if (any(greaterThanEqual(gl_GlobalInvocationID.xyz * miplevel, volumeSlabDims))) {
    return;
  }

  vec3 p = vec3(gl_GlobalInvocationID.xyz);

  // slots |= (uint(collect) << gl_ThreadInWarpNV);
  //
  // barrier();

  if (!voxel_mip_get(p, miplevel, palette_idx)) {
    return;
  }

  if (!visible(p)) return;

  //uint slot = EncodeMorton3(uvec3(p * 2.0));
  // uint code = EncodeMorton3(uvec3(p));
  // uint bucketIdx = code >> SPLAT_BUCKET_SIZE_SHIFT;

  // uint active_threads = activeThreadsNV();
  // uint leader = findMSB(active_threads);
  // uint rank = bitCount(leader & gl_ThreadInWarpNV);
  //

  #if 0
    int change = bitCount(active_threads);

    uint rank = bitCount(leader & gl_ThreadInWarpNV);
    uint warp_res;
    if (rank == leader) {//(leader & gl_ThreadInWarpNV) > 0)  {
      warp_res = atomicAdd(command.count, change);
    }
    bool nop;

    warp_res = shuffleNV(warp_res, gl_ThreadInWarpNV, 32, nop);
    uint splatIdx = warp_res + rank;
  #else
    uint splatIdx = atomicAdd(command.count, 1);
  #endif

  Splat entry;
  entry.position = vec4(p, 1.0);
  // if (findLSB(active_threads) == gl_ThreadInWarpNV) {
  //   entry.color = vec4(1.0, 0.0, leader == 1? 1.0 : 0.0, 1.0);
  //   entry.color = vec4(0.5);
  // } else {
  //   entry.color =  vec4(
  //     hsl(vec3(float(gl_ThreadInWarpNV)/32.0, 0.9, 0.5)),
  //     1.0
  //   );
  // }

  // entry.color =  vec4(
  //   hsl(vec3(float(splatIdx)/10000000.0, 0.9, 0.5)),
  //   1.0
  // );

  //entry.color = leader == gl_ThreadInWarpNV ? vec4(1.0, 0.0, 1.0, 1.0): vec4(0.2);
  entry.color = vec4(palette_color(palette_idx), 1.0);
  //buckets[bucketIdx].splats[splatIdx] = entry;
  splats[splatIdx] = entry;
}
