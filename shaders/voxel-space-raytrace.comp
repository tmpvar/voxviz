#version 430 core
#extension GL_NV_shader_buffer_load: enable
#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable

layout( local_size_x = 128, local_size_y = 8, local_size_z = 1 ) in;

#include "ray-aabb.glsl"
#include "dda-cursor.glsl"
#include "palette.glsl"
#include "cosine-direction.glsl"
#include "voxel-space.glsl"
#include "hsl.glsl"

uniform uvec2 out_color_dims;
uniform mat4 VP;
uniform uvec2 resolution;

layout (std430, binding=1) buffer volumeSlabMip0 {
  uint8_t volumeMip0[];
};

layout (std430, binding=2) buffer volumeSlabMip1 {
  uint8_t volumeMip1[];
};

layout (std430, binding=3) buffer volumeSlabMip2 {
  uint8_t volumeMip2[];
};

layout (std430, binding=4) buffer volumeSlabMip3 {
  uint8_t volumeMip3[];
};

layout (std430, binding=5) buffer volumeSlabMip4 {
  uint8_t volumeMip4[];
};

layout (std430, binding=6) buffer volumeSlabMip5 {
  uint8_t volumeMip5[];
};

layout (std430, binding=7) buffer volumeSlabMip6 {
  uint8_t volumeMip6[];
};

layout (std430, binding=8) buffer outColorBuffer {
  vec4 out_color[];
};

layout (std430, binding=9) buffer outTerminationBuffer {
  RayTermination out_termination[];
};

layout (std430, binding=10) buffer blueNoiseBuffer {
  vec4 blueNoise[];
};

// main binds
uniform float debug;
uniform int showHeat;
uniform float maxDistance;
uniform vec3 eye;
uniform vec3 dims;
uniform uint time;
uniform uint terminationBufferIdx;

uniform uvec3 lightPos;
uniform vec3 lightColor;

uniform vec3 characterPos;

#define ITERATIONS 256

bool voxel_get(vec3 pos, out uint8_t palette_idx) {
  vec3 p = floor(pos);
  if (
    any(lessThan(p, vec3(0))) ||
    any(greaterThanEqual(p, vec3(dims)))
  ) {
    return false;
  }

  uint idx = uint(
    p.x +
    p.y * dims.x +
    p.z * dims.x * dims.y
  );

  palette_idx = volumeMip0[idx];

  return palette_idx > uint8_t(0);
}

bool voxel_get_mip1(vec3 pos, out uint8_t palette_idx) {
  // vec3 d = dims / 2.0;
  // pos = pos / 2.0;
  vec3 d = floor(dims / 2.0);
  vec3 p = floor(pos / 2.0);
  if (
    any(lessThan(p, vec3(0.0))) ||
    any(greaterThanEqual(p, vec3(d)))
  ) {
    return false;
  }

  uint idx = uint(
    (
      p.x +
      p.y * d.x +
      p.z * d.x * d.y
    )
  );

  palette_idx = volumeMip1[idx];

  return palette_idx > uint8_t(0);
}

bool voxel_get_mip2(vec3 pos, out uint8_t palette_idx) {
  // vec3 d = dims / 2.0;
  // pos = pos / 2.0;
  vec3 d = floor(dims / 4.0);
  vec3 p = floor(pos / 4.0);
  if (
    any(lessThan(p, vec3(0.0))) ||
    any(greaterThanEqual(p, vec3(d)))
  ) {
    return false;
  }

  uint idx = uint(
    (
      p.x +
      p.y * d.x +
      p.z * d.x * d.y
    )
  );

  palette_idx = volumeMip2[idx];

  return palette_idx > uint8_t(0);
}

bool voxel_get_mip3(vec3 pos, out uint8_t palette_idx) {
  vec3 d = floor(dims / 8.0);
  vec3 p = floor(pos / 8.0);
  if (any(lessThan(p, ivec3(0))) || any(greaterThanEqual(p, ivec3(d)))) {
    return false;
  }

  uint idx = uint(
    p.x +
    p.y * d.x +
    p.z * d.x * d.y
  );

  palette_idx = volumeMip3[idx];
  return palette_idx > uint8_t(0);
}

bool voxel_get_mip4(vec3 pos, out uint8_t palette_idx) {
  vec3 d = floor(dims / 16.0);
  vec3 p = floor(pos / 16.0);
  if (any(lessThan(p, ivec3(0))) || any(greaterThanEqual(p, ivec3(d)))) {
    return false;
  }

  uint idx = uint(
    p.x +
    p.y * d.x +
    p.z * d.x * d.y
  );

  palette_idx = volumeMip4[idx];

  return palette_idx > uint8_t(0);
}

bool voxel_get_mip5(vec3 pos, out uint8_t palette_idx) {
  vec3 d = floor(dims / 32.0);
  vec3 p = floor(pos / 32.0);
  if (any(lessThan(p, ivec3(0))) || any(greaterThanEqual(p, ivec3(d)))) {
    return false;
  }

  uint idx = uint(
    p.x +
    p.y * d.x +
    p.z * d.x * d.y
  );

  palette_idx = volumeMip5[idx];

  return palette_idx > uint8_t(0);
}

bool voxel_get_mip6(vec3 pos, out uint8_t palette_idx) {
  vec3 d = floor(dims / 64.0);
  vec3 p = floor(pos / 64.0);
  if (any(lessThan(p, ivec3(0))) || any(greaterThanEqual(p, ivec3(d)))) {
    return false;
  }

  uint idx = uint(
    p.x +
    p.y * d.x +
    p.z * d.x * d.y
  );

  palette_idx = volumeMip5[idx];

  return palette_idx > uint8_t(0);
}

vec2 noise2d(uvec3 pos) {
  uint idx = (pos.x % 64) + (pos.y%64) * 64 + (pos.z%64) * 64 * 64;
  return 2.0 * blueNoise[idx].xy - 1.0;
}

vec3 cangle(uvec3 pos, vec3 normal) {
  vec2 uv = noise2d(pos) * 0.1;
  float a = 6.2831853 * uv.y;
  float u = uv.x;//2.0*uv.x - 1.0;
  return normalize( normal + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );
}

vec3 cdir(in uint seed, in vec3 normal) {
  // uint slice = (time % 64) * 4096;

  vec2 bn = 2.0 * blueNoise[(seed * time * 1000) % (4096 * 64)].xy - 0.5;

  float u = bn.x;
  float v = bn.y;

	// // method 3 by fizzer: http://www.amietia.com/lambertnotangent.html
  float a = 6.2831853 * v;
  //u = 2.0*u - 1.0;
  return normalize(
    normal + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u)
  );
}

float trace_light1(in DDACursor cursor, vec2 uv, vec3 worldLightPos) {
  vec3 normal = vec3(cursor.mask);
  float div = 1.0;

  vec3 mapPos = cursor.mapPos / div;
  vec3 hd = (dims * 0.5) / div;
  vec3 lightPos = (worldLightPos / div);
  const uint steps = 512;
  vec3 cd = cdir(
    uint(gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * resolution.x),
    normal
  ) * 0.5; // roughness

  // float intensity = (1.0 - distance(lightPos, mapPos) / float(steps)) * 2.0;
  // if (distance(lightPos, mapPos) > float(steps)) {
  //   return -intensity;
  // }
  float intensity = 1.0;

  //vec3 new_ray_dir = cd + lightPos - mapPos / div;
  vec3 new_ray_dir = (lightPos - mapPos);
  new_ray_dir = normalize(new_ray_dir);

  DDACursor c = dda_cursor_create(
    (mapPos - hd + sign(new_ray_dir) * normal),
    vec3(0.0),
    hd,
    new_ray_dir
  );

  uint8_t noop;
  vec3 found_normal;
  for (int i=0; i<steps; i++) {
    if (voxel_get(c.mapPos, noop)) {
      return -intensity;
    }

    if (distance(c.rayPos + hd, worldLightPos) < 1.0) {
      return intensity;
    }
    dda_cursor_step(c, found_normal);
  }
  return -intensity;//2.0 - length((lightPos - cursor.rayPos)/vec3(dims));
}

float trace_light(in DDACursor cursor, vec2 uv, vec3 worldLightPos) {
  vec3 normal = vec3(cursor.mask);
  const uint steps = 128;
  float div = 1.0;
  vec3 cd = cdir(
    uint(gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * resolution.x),
    normal
  ); // roughness


  //vec3 new_ray_dir = cd + lightPos - mapPos / div;
  vec3 new_ray_dir = (worldLightPos - (floor(cursor.rayPos) + 0.5));
  new_ray_dir = normalize(new_ray_dir);

  uint8_t noop;
  vec3 pos = (cursor.rayPos + normal * 0.1 + new_ray_dir)  / div;
  vec3 origin = pos;
  float intensity = 1.0;//(distance(lightPos, pos) / float(steps));
  if (distance(worldLightPos, cursor.rayPos) > float(steps * div * 2)) {
    return 0.0;
  }


  for (int i=0; i<steps; i++) {
    //
    if (voxel_get(round(pos), noop)) {

      return 0.00001;// - distance(origin, worldLightPos) / 64.0;
    }

    if (distance(pos, round(worldLightPos / div)) < div * 3.0) {
      return intensity * 0.75;
    }

    pos += (new_ray_dir * (div * 0.75));

  }
  return 0.0;
}

float trace_sky(in DDACursor cursor, vec2 uv) {
  vec3 normal = vec3(cursor.mask);
  float div = 2.0;
  vec3 mapPos = cursor.mapPos / div;
  vec3 hd = (dims * 0.5) / div;

  vec3 cd = normalize(cdir(
    uint(
      gl_GlobalInvocationID.x +
      gl_GlobalInvocationID.y * resolution.x
    ),
    normal
  )); // roughness

  vec3 new_ray_dir = vec3(
    0.0,
    1.0,
    0.0
  ) ;
  new_ray_dir = normalize(new_ray_dir) * div;

  DDACursor c = dda_cursor_create(
    (cursor.mapPos / div - hd + new_ray_dir + sign(new_ray_dir) * normal + cd * 0.5),
    vec3(0.0),
    hd,
    new_ray_dir
  );
  // vec3 pos = cursor.mapPos / 2.0;// + normal*div + new_ray_dir;// + normal;// + new_ray_dir*div;// + (normal*div + cd *div * 2.0 +  new_ray_dir * div + cd * div * 0.5) * div;// normal * 4;// + cd * 0.005;
  // pos += normal + vec3(0.0, dims.y/2.0-, 0.0);
  // pos += sign(new_ray_dir);
  // pos += cd;
  // //pos += sign(new_ray_dir) * 2.0 + normal * 2.0 + new_ray_dir;

  uint8_t noop;
  vec3 found_normal;
  for (int i=0; i<64; i++) {
    if (voxel_get_mip1(c.mapPos, noop)) {
    // if (voxel_get_mip1(pos, noop)) {
      return -1.0;
    }
    dda_cursor_step(c, found_normal);
    // pos += new_ray_dir;
  }
  return c.mapPos.y >= dims.y / 4.0 ? 0.5 : -1.0;
}

vec3 trace_reflection(in DDACursor cursor, vec2 uv) {
  vec3 hd = (dims * 0.5) / 2;
  vec3 normal = normalize(vec3(cursor.mask));
  vec3 mapPos = cursor.mapPos / 2.0;

  vec3 cd = vec3(0.0);

  cd = cdir(
    uint(gl_GlobalInvocationID.x + gl_GlobalInvocationID.y * resolution.x),
    normal
  ) * 0.15; // roughness

  vec3 new_ray_dir = reflect(normalize(cursor.rayDir) + cd, normal);
  new_ray_dir = normalize(new_ray_dir);

  DDACursor c = dda_cursor_create(
    cursor.rayPos / 2.0 + sign(new_ray_dir) + normal * 2.0 + new_ray_dir,
    hd,
    hd,
    new_ray_dir
  );

  uint8_t noop;
  vec3 found_normal;
  for (int i=0; i<64; i++) {
    if (voxel_get_mip1(c.mapPos, noop)) {
      return c.mapPos * 2.0;
    }
    dda_cursor_step(c, found_normal);
  }
  return vec3(-1.0);
}

vec3 compute_ray_dir(vec2 uv, mat4 inv) {
  vec4 far = inv * vec4(-uv.x, uv.y, 1.0, 1.0);
  far /= far.w;
  vec4 near = inv * vec4(-uv.x, uv.y, 0.5, 1.0);
  near /= near.w;

  return normalize(far.xyz - near.xyz);
}

float sum(vec3 v) { return dot(v, vec3(1.0)); }

bool voxel_mip(in vec3 pos, const in uint mip, out uint8_t palette_idx) {
  vec3 gridPos = pos;// * dims;
  if (mip == 0) {
    return voxel_get(gridPos, palette_idx);
  }

  if (mip == 1) {
    return voxel_get_mip1(gridPos, palette_idx);
  }

  if (mip == 2) {
    return voxel_get_mip2(gridPos, palette_idx);
  }

  if (mip == 3) {
    return voxel_get_mip3(gridPos, palette_idx);
  }

  if (mip == 4) {
    return voxel_get_mip4(gridPos, palette_idx);
  }

  if (mip == 5) {
    return voxel_get_mip5(gridPos, palette_idx);
  }

  if (mip == 6) {
    return voxel_get_mip6(gridPos, palette_idx);
  }

  return false;
}

float mincomp(vec3 v) {
  return min(v.x, min(v.y, v.z));
}

void main() {
  if (any(greaterThanEqual(gl_GlobalInvocationID.xy, resolution))) {
    return;
  }

  vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(resolution) * 2.0 - 1.0;
  uvec2 out_color_pos = gl_GlobalInvocationID.xy;
  uint out_color_idx = out_color_pos.x + out_color_pos.y * resolution.x;
  uint out_termination_idx = out_color_idx;// + terminationBufferIdx;
  vec3 in_ray_dir = compute_ray_dir(uv, inverse(VP));

  float found_distance;
  vec3 found_normal;
  vec3 hd = dims * 0.5;

  bool hit;
  if (all(greaterThanEqual(eye, vec3(0.0))) && all(lessThan(eye, dims))) {
    hit = true;//pos = eye + in_ray_dir * 0.001;
    found_distance = 0.0;
  } else {
    hit = ailaWaldHitAABox(
      hd,
      hd,
      eye,
      in_ray_dir,
      1.0 / in_ray_dir,
      found_distance,
      found_normal
    );
    found_distance += 0.1;
  }
  out_termination[out_termination_idx].color = vec4(0.2);
  if (!hit) {
    return;
  }

  uint8_t palette_idx;
  vec3 c = vec3(0.2);
  int i;

  int mip = 4;
  vec3 d = in_ray_dir;
  vec3 id = 1.0 / d;
  vec3 p = eye + d * found_distance;
  //d = vec3(0.0, 0.0, 1.0/dims.z);
  //pos = vec3( gl_GlobalInvocationID.xy / resolution, 1);

  float dt = 1.0 / length(dims);
  float t = found_distance;
  float opacityDiv = 1.0 / 8.0;

  int minMip = 0;
  int maxMip = 5;
  mip = maxMip;
  float mipSize = (float(1<<(mip)));
  float invMipSize = 1.0 / mipSize;
  for (i=0; i<ITERATIONS; i++) {
    if (
      any(lessThan(p, vec3(0.0))) ||
      any(greaterThan(p, vec3(dims)))
    ) {
      break;
    }

    if (voxel_mip(p, mip, palette_idx)) {
      if (mip == minMip) {
        c = vec3(float(palette_idx) / 8.0);
        //voxel_mip(p, 0, palette_idx);
        c = palette_color(palette_idx);
        break;
      }

      mip = max(mip - 1, minMip);
      t -= dt * 0.00125;

      mipSize = (float(1<<(mip)));
      invMipSize = 1.0 / mipSize;
      continue;
    }
    else if (mip < maxMip && !voxel_mip(p, min(mip + 1, maxMip), palette_idx)) {
      mip++;
      mipSize = (float(1<<(mip)));
      invMipSize = 1.0 / mipSize;
      t += dt * 0.00125;
    }

    vec3 deltas = (step(0.0, d) - fract(p * invMipSize)) * id;
    dt = max(mincomp(deltas), 0.0001) * mipSize;
    t += dt;
    t += max(0.1,t/256);
    p = eye + d * t;// * t;// * (float(1<<(mip)));
  }
  if (debug == 1.0) {
    c = hsl(vec3(0.7 - (float(i)/float(ITERATIONS) * 0.9), 0.9, 0.5));
  }

  out_termination[out_termination_idx].color = vec4(c, 1.0);
}
