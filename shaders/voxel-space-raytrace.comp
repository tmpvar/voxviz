#version 430 core
#extension GL_NV_shader_buffer_load: enable
#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable

layout( local_size_x = 32 , local_size_y = 16, local_size_z = 1 ) in;

#include "ray-aabb.glsl"
#include "dda-cursor.glsl"
#include "palette.glsl"
#include "cosine-direction.glsl"
#include "voxel-space.glsl"
#include "hsl.glsl"

uniform uvec2 out_color_dims;
uniform mat4 VP;
uniform uvec2 resolution;
uniform float debug;
uniform vec3 eye;
uniform vec3 dims;
uniform uint time;
uniform uint terminationBufferIdx;
uniform uvec3 lightPos;
uniform vec3 lightColor;

uniform vec3 characterPos;

// uses bindings 1-7 and requires `dims`
#include "voxel-space-mips.glsl"

layout (std430, binding=9) buffer outTerminationBuffer {
  RayTermination out_termination[];
};

layout (std430, binding=10) buffer blueNoiseBuffer {
  vec4 blueNoise[];
};

layout (std430, binding=11) buffer rayMaskBuffer {
  uint rayMask[];
};

#define ITERATIONS 1024

struct RayHit {
  vec3 pos;
  vec3 dir;
  float t;
  vec3 normal;
};

vec3 compute_ray_dir(vec2 uv, mat4 inv) {
  vec4 far = inv * vec4(-uv.x, uv.y, 1.0, 1.0);
  far /= far.w;
  vec4 near = inv * vec4(-uv.x, uv.y, 0.5, 1.0);
  near /= near.w;

  return normalize(far.xyz - near.xyz);
}

float sum(vec3 v) { return dot(v, vec3(1.0)); }

void main() {
  if (any(greaterThanEqual(gl_GlobalInvocationID.xy, resolution))) {
    return;
  }

  vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(resolution) * 2.0 - 1.0;
  uvec2 out_color_pos = gl_GlobalInvocationID.xy;
  uint out_color_idx = out_color_pos.x + out_color_pos.y * resolution.x;
  uint out_termination_idx = out_color_idx + terminationBufferIdx;
  vec3 in_ray_dir = compute_ray_dir(uv, inverse(VP));

  float found_distance;
  vec3 found_normal = vec3(0.0);
  vec3 hd = dims * 0.5;

  bool hit;
  if (all(greaterThanEqual(eye, vec3(0.0))) && all(lessThan(eye, dims))) {
    hit = true;//pos = eye + in_ray_dir * 0.001;
    found_distance = 0.0;
  } else {
    hit = ourIntersectBoxCommon(
      hd,
      hd,
      eye,
      in_ray_dir,
      1.0 / in_ray_dir,
      found_distance,
      found_normal
    );
    found_distance += 0.1;
  }
  out_termination[out_termination_idx].color = vec4(0.0);
  out_termination[out_termination_idx].rayDir = vec4(in_ray_dir, 1.0);
  if (!hit) {
    out_termination[out_termination_idx].position = vec4(-1.0);
    out_termination[out_termination_idx].normal = vec4(found_normal, 1.0);
    return;
  }


  uint8_t palette_idx;
  uint8_t noop;
  vec3 c = vec3(0.0);
  int i;

  int mip = 0;
  vec3 d = in_ray_dir;
  vec3 id = 1.0 / d;
  vec3 p = eye + d * found_distance;
  vec3 prevP = eye - d * 2.0;
  //d = vec3(0.0, 0.0, 1.0/dims.z);
  //pos = vec3( gl_GlobalInvocationID.xy / resolution, 1);

  float dt = 1.0 / length(dims);
  float t = found_distance;
  float opacityDiv = 1.0 / 8.0;

  int minMip = 0;
  int maxMip = 3;
  mip = 0;
  float mipSize = (float(1<<(mip)));
  float invMipSize = 1.0 / mipSize;
  vec3 mask;
  bool miss = true;
  for (i=0; i<ITERATIONS; i++) {
    if (
      any(lessThan(p, vec3(0.0))) ||
      any(greaterThanEqual(p, vec3(dims)))
    ) {
      break;
    }

    if (voxel_mip(p, mip, palette_idx)) {
      if (mip == minMip) {
        c = palette_color(palette_idx);

        // if the ray have moved since we intersected the outer bounding box then
        // we should recompute a normal.
        if (found_distance != t) {
          found_normal = -sign(d) *
                          step(prevP.xyz, prevP.yzx) *
                          step(prevP.xyz, prevP.zxy);
        }
        miss = false;
        break;
      }

      mip = max(mip - 1, minMip);
      t -= dt * 0.0125;

      mipSize = (float(1<<(mip)));
      invMipSize = 1.0 / mipSize;
      continue;
    }
    else if (mip < maxMip && !voxel_mip(p, min(mip + 1, maxMip), palette_idx)) {
      mip++;
      mipSize = (float(1<<(mip)));
      invMipSize = 1.0 / mipSize;
      t += dt * 0.0125;
    }

    vec3 deltas = (step(0.0, d) - fract(p * invMipSize)) * id;
    dt = max(mincomp(deltas), 0.00005) * mipSize;
    t += dt;
    // FIXME: we get ~1ms back if this is enabled, but lose the ability to
    //        compute good face normals. There is likely a better mechanism
    //        for increasing marching speed at further distances (cone marching?)
    //t += max(0.1,t * 0.01);
    prevP = deltas;
    p = eye + d * t;
  }
  if (debug == 1.0) {
    c = hsl(vec3(0.7 - (float(i)/float(ITERATIONS) * 0.9), 0.9, 0.5));
  }

  out_termination[out_termination_idx].normal = vec4(0.0);
  out_termination[out_termination_idx].position = vec4(-1.0);
  out_termination[out_termination_idx].color = vec4(c, 0.0);

  if (miss) {
    return;
  }

  if (voxel_mip(p + found_normal, 0, noop)) {
    return;
  }

  uvec3 on = uvec3(notEqual(vec3(0.0), found_normal));
  uvec3 negative = uvec3(lessThan(vec3(0.0), found_normal));

  // b00110100
  //    ||||||_ x non-zero (false)
  //    |||||_ x negative (false)
  //    ||||_ y non-zero (true)
  //    |||_ y negative (false)
  //    ||_ z non-zero (true)
  //    |_ z negative (true)
  uint update =
    (on.x << 0) | (negative.x << 1) |
    (on.y << 2) | (negative.y << 3) |
    (on.z << 4) | (negative.z << 5);

  atomicOr(rayMask[voxel_get_idx(p)], update);

  out_termination[out_termination_idx].color = vec4(c, 1.0);
  out_termination[out_termination_idx].position = vec4(p, 1.0);
  out_termination[out_termination_idx].normal = vec4(found_normal, 1.0);
}

void main_dda() {
  if (any(greaterThanEqual(gl_GlobalInvocationID.xy, resolution))) {
    return;
  }

  vec2 uv = vec2(gl_GlobalInvocationID.xy) / vec2(resolution) * 2.0 - 1.0;
  uvec2 out_color_pos = gl_GlobalInvocationID.xy;
  uint out_color_idx = out_color_pos.x + out_color_pos.y * resolution.x;
  uint out_termination_idx = out_color_idx + terminationBufferIdx;
  vec3 in_ray_dir = compute_ray_dir(uv, inverse(VP));

  float found_distance;
  vec3 found_normal = vec3(0.0);
  vec3 hd = dims * 0.5;

  bool hit;
  if (all(greaterThanEqual(eye, vec3(0.0))) && all(lessThan(eye, dims))) {
    hit = true;//pos = eye + in_ray_dir * 0.001;
    found_distance = 0.0;
  } else {
    hit = ourIntersectBoxCommon(
      hd,
      hd,
      eye,
      in_ray_dir,
      1.0 / in_ray_dir,
      found_distance,
      found_normal
    );
    found_distance += 0.1;
  }

  out_termination[out_termination_idx].position = vec4(-1.0);
  out_termination[out_termination_idx].color = vec4(0.0);
  out_termination[out_termination_idx].normal = vec4(0.0);
  out_termination[out_termination_idx].rayDir = vec4(in_ray_dir, 1.0);

  if (!hit) {
    return;
  }

  vec3 p = eye + in_ray_dir * found_distance;

  DDACursor cursor = dda_cursor_create(
    p,
    vec3(dims)/2.0,
    vec3(dims)/2.0,
    in_ray_dir
  );

  bool miss = true;
  vec3 c = vec3(0.0);
  int i = 0;
  uint8_t palette_idx;
  for (i=0; i<ITERATIONS; i++) {
    if (voxel_mip(cursor.rayPos, 0, palette_idx)) {
      c = palette_color(palette_idx);
      miss = false;
      break;
    }

    dda_cursor_step(cursor, found_normal);
  }

  if (debug == 1.0) {
    c = hsl(vec3(0.7 - (float(i)/float(ITERATIONS) * 0.9), 0.9, 0.5));
  }

  if (miss) {
    return;
  }

  out_termination[out_termination_idx].normal = vec4(found_normal, 1.0);
  out_termination[out_termination_idx].color = vec4(c, 1.0);
  out_termination[out_termination_idx].position = vec4(cursor.rayPos, 1.0);

  if (voxel_mip(cursor.rayPos + found_normal, 0, palette_idx)) {
    return;
  }

  uvec3 on = uvec3(notEqual(vec3(0.0), found_normal));
  uvec3 negative = uvec3(lessThan(vec3(0.0), found_normal));

  // b00110100
  //    ||||||_ x non-zero (false)
  //    |||||_ x negative (false)
  //    ||||_ y non-zero (true)
  //    |||_ y negative (false)
  //    ||_ z non-zero (true)
  //    |_ z negative (true)
  uint update =
    (on.x << 0) | (negative.x << 1) |
    (on.y << 2) | (negative.y << 3) |
    (on.z << 4) | (negative.z << 5);

  atomicOr(rayMask[voxel_get_idx(cursor.rayPos)], update);

  // out_termination[out_termination_idx].normal = vec4(
  //   (update & (1<<0)) > 0 ? 1.0 : 0.0,
  //   (update & (1<<2)) > 0 ? 1.0 : 0.0,
  //   (update & (1<<4)) > 0 ? 1.0 : 0.0,
  //   1.0
  // );
  // // out_termination[out_termination_idx].normal = vec4(1.0);
  // // return;
  //
  // out_termination[out_termination_idx].color = vec4(c, 1.0);
  // out_termination[out_termination_idx].position = miss ? vec4(-1.0) : vec4(p, 1.0);
  // out_termination[out_termination_idx].normal = vec4(found_normal, 1.0);

}
