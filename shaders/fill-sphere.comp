#version 430 core
#extension GL_NV_shader_buffer_load: enable
//#extension GL_ARB_compute_variable_group_size: enable
#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable
#include "../include/core.h"
#include "voxel.glsl"

uniform uint32_t *volume;

layout( local_size_x = 32, local_size_y = 32, local_size_z = 1 ) in;


void main() {
  uvec3 pos = gl_GlobalInvocationID.xyz;
  // uint idx = gl_LocalInvocationIndex;
  uint idx = (pos.x + pos.y * BRICK_DIAMETER + pos.z * BRICK_DIAMETER * BRICK_DIAMETER);
  float hd = float(BRICK_RADIUS);

  float d = distance(vec3(pos) , vec3(hd)) - hd;
  volume[idx] = d <= 0.0 ? 1 : 0;
}

void main1() {
  uvec3 pos = gl_GlobalInvocationID.xyz;
  uint idx = gl_LocalInvocationIndex;
  float hd = float(BRICK_RADIUS);
  uint word = uint(float(idx) / float(VOXEL_WORD_BITS));
  uint bits = 0;

  for (uint mask=0; mask<8; mask++) {
    vec3 offset = vec3(
      1 & mask,
      2 & mask,
      4 & mask
    );

    float d = distance(vec3(pos) + offset, vec3(hd)) - hd;
    bits |= d < 0.0 ? mask : 0;
  }

  volume[idx] = bits;
}


void main2() {
// pos becomes `word` and then we iterate 32 times over the bits and
// convert them into 3d coords via lookup table(?). Finally we can
// take the resulting word and write into the volume at a specific index
	uint idx = gl_GlobalInvocationID.x;
	uint lower = idx * VOXEL_WORD_BITS;
	uint upper = lower + VOXEL_WORD_BITS;
	uint bits = 0;
	float hd = float(BRICK_RADIUS);

	for (uint p = lower; p < upper; p++) {
		uint mask = 1 << (p - lower);
		uvec3 pos = uvec3(
			p % BRICK_DIAMETER,
			(p / BRICK_DIAMETER) % BRICK_DIAMETER,
			((p / BRICK_DIAMETER) / BRICK_DIAMETER) % BRICK_DIAMETER
		);

		float d = distance(vec3(pos), vec3(hd)) - hd;
		bits |= d < 0.0 ? mask : 0;
	}

	volume[idx] = bits;
}
