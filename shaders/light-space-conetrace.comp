#version 430 core
#extension GL_NV_shader_buffer_load: enable
#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable

layout( local_size_x = 64, local_size_y = 16, local_size_z = 1 ) in;

#include "voxel-space.glsl"
#include "voxel-space-mips.glsl"
#include "light-space-mips.glsl"
#include "hsl.glsl"
#include "palette.glsl"

uniform uvec2 out_color_dims;
uniform mat4 VP;
uniform uvec2 resolution;

uniform uint time;
uniform uint terminationBufferIdx;


layout (std430) buffer outTerminationBuffer {
  RayTermination out_termination[];
};

layout (std430) buffer blueNoiseBuffer {
  vec4 blueNoise[];
};

#include "cdir.glsl"

float sum(vec3 v) { return dot(v, vec3(1.0)); }



void main2() {
  uvec2 screen_pos = gl_GlobalInvocationID.xy;
  uint screen_idx = screen_pos.x + screen_pos.y * resolution.x;
  uint out_idx = screen_idx;// + terminationBufferIdx;

  RayTermination o = out_termination[out_idx];

  if (all(equal(o.position, vec4(-1.0)))) {
    return;
  }

  vec4 acc = vec4(0.0);
  vec4 tmp = vec4(0.0);
  vec3 p = o.position.xyz;
  // if (false) {
  //   light_mip_get(o.position.xyz, 1, tmp);
  //   acc+=tmp;
  //   light_mip_get(o.position.xyz + uvec3(1, 0, 0), 0, tmp);
  //   acc+=tmp;
  //   light_mip_get(o.position.xyz + uvec3(-1, 0, 0), 0, tmp);
  //   acc+=tmp;
  //
  //   // light_mip_get(o.position.xyz + o.rayDir.xyz, 0, tmp);
  //
  //   // acc+=tmp;
  //   //
  //   //
  //   acc /= 3;
  // } else {
  //   for (uint j = 0; j<2; j++) {
  //     vec3 jitter = cdir(j * screen_idx, o.normal.xyz);
  //     for (uint i=0; i<7; i++) {
  //       if (light_mip_get(p + o.normal.xyz - jitter, i, tmp)) {
  //         if (tmp.a > 0.0) {
  //           acc += tmp * (1.0 - float(i) / float(MAX_MIPS));
  //         }
  //       }
  //     }
  //   }
  //   acc /= (MAX_MIPS);
  // }

  light_mip_get(o.position.xyz, 0, tmp);
  acc = tmp;

  out_termination[out_idx].color = vec4(1.0, 0.0, 0.0, 1.0);//tmp;//o.color.rgba * (acc);//vec4(o.color.rgb * (acc.rgb * acc.a), 1.0);
}

void main3() {
  uvec2 screen_pos = gl_GlobalInvocationID.xy;
  uint screen_idx = screen_pos.x + screen_pos.y * resolution.x;
  uint out_idx = screen_idx;// + terminationBufferIdx;

  RayTermination o = out_termination[out_idx];

  if (all(equal(o.position, vec4(-1.0)))) {
    return;
  }
  vec4 acc = vec4(0.0);
  vec4 tmp;
  float t = 0.1;
  float mip = 0.0;
  int steps = 5;
  int rays = 4;
  vec3 n = o.normal.xyz;
  uint8_t occlusion;

  for (int r=0; r<rays; r++) {
    vec3 jitter = cdir(screen_idx * r, n);
    vec3 jitter2 = cdir(screen_idx * r * 2, n);
    vec3 p = o.position.xyz + jitter * t;
    float intensity = 1.0;

    for (uint i=0; i<steps && intensity > 0.0; i++) {
      if (voxel_mip_get(p, uint(mip), occlusion)) {
        intensity -= float(occlusion)/255.0;
      }
      if (light_mip_get(p, uint(mip), tmp)) {
        acc += tmp * (1.0 - mip/MAX_MIPS) * intensity;
      }
      t = float(i) / float(rays);
      mip = 2 * float(i)/float(steps);
    }
  }
  acc /= float(rays);
  out_termination[out_idx].color = o.color.rgba * acc * acc.a;//vec4(o.color.rgb * (acc.rgb * acc.a), 1.0);
}

void main() {
  uvec2 screen_pos = gl_GlobalInvocationID.xy;
  uint screen_idx = screen_pos.x + screen_pos.y * resolution.x;
  uint out_idx = screen_idx;// + terminationBufferIdx;

  RayTermination o = out_termination[out_idx];

  if (all(equal(o.position, vec4(-1.0)))) {
    return;
  }

  vec4 acc = vec4(0.0);
  vec4 tmp;
  uint mips = 2;
  for (uint i=1; i<mips; i++) {
    if (light_mip_get(o.position.xyz, i, tmp)) {
       acc += tmp * (1.0 - float(i) / MAX_MIPS);
     }
  }
  acc /= float(mips);
  acc = sqrt(acc);

  out_termination[out_idx].color = o.color.rgba * acc * acc.a;//vec4(o.color.rgb * (acc.rgb * acc.a), 1.0);
}

void main1() {

  uvec2 screen_pos = gl_GlobalInvocationID.xy;
  uint screen_idx = screen_pos.x + screen_pos.y * resolution.x;
  uint out_idx = screen_idx;// + terminationBufferIdx;

  RayTermination o = out_termination[out_idx];

  if (all(equal(o.position, vec4(-1.0)))) {
    return;
  }

  vec3 normal = o.normal.xyz;
  vec3 origin = o.position.xyz + normal;
  vec3 rayDir = o.rayDir.xyz;
  vec4 voxelColor = o.color;
  // float intensity = 0.0;

  uvec3 udims = uvec3(lightSlabDims);
  uint8_t palette_idx;
  float t = 0.0;
  float steps = 8.0;
  vec4 acc = vec4(0.0);
  float ticks = 0.0;

  vec3 cd = cdir(
    uint(
      float(time) * length(o.position)
    ),
    normal
  ) * 0.1;

  vec3 dir = normalize(normal + cd);
  float i = 0;
  float intensity = 1.0;
  vec4 tmp;
  for (i=0.0; i<steps && intensity > 0.0; i++) {
    vec3 p = origin + dir * t;

    if (
      any(lessThan(p, vec3(0.0))) ||
      any(greaterThanEqual(p, vec3(lightSlabDims)))
    ) {
      break;
    }

    // for (uint i=0; i<MAX_MIPS; i++) {
    //   if (light_mip_get(p, i, tmp)) {
    //     acc += tmp * (1.0 - float(i) / float(MAX_MIPS)) * intensity;
    //   }
    // }


    uint mipLevel = max(1, uint(t * 0.15));

    if (voxel_mip_get(p, mipLevel, palette_idx)) {
      uint occ = uint(palette_idx);
      float total = 0.0;
      total += (occ & (1<<0)) > 0 ? 1.0 : 0.0;
      total += (occ & (1<<1)) > 0 ? 1.0 : 0.0;
      total += (occ & (1<<2)) > 0 ? 1.0 : 0.0;
      total += (occ & (1<<3)) > 0 ? 1.0 : 0.0;
      total += (occ & (1<<4)) > 0 ? 1.0 : 0.0;
      total += (occ & (1<<5)) > 0 ? 1.0 : 0.0;
      total += (occ & (1<<6)) > 0 ? 1.0 : 0.0;
      total += (occ & (1<<7)) > 0 ? 1.0 : 0.0;
      intensity *= total / 8.0;
    //   //break;
    }

  //   Light light = lights[i];
  //   voxelColor = max(voxelColor, light.color * trace_light(o, light));
    t += max(1.0, t*0.5);
  }
  acc /= i;
  out_termination[out_idx].color =  sqrt(voxelColor * acc * acc.a);
}
