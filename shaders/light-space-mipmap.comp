#version 430 core
#extension GL_NV_shader_buffer_load: enable
#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable

layout( local_size_x = 128, local_size_y = 1, local_size_z = 1 ) in;

layout (std430) buffer volumeSlabBuffer {
  uint8_t volumeSlab[];
};
uniform vec3 volumeSlabDims;

uniform uvec3 mipDims;
uniform uvec3 lowerMipDims;
uniform uint mipLevel;

// precomputed voxel lod buffer position and size ratios
// vec2(start, length)
const vec2 lod_defs[8] = vec2[8](
    vec2(0, 1),
    vec2(1, 0.125),
    vec2(1.125, 0.015625),
    vec2(1.140625, 0.001953125),
    vec2(1.142578125, 0.000244140625),
    vec2(1.142822265625, 0.000030517578125),
    vec2(1.142852783203125, 0.000003814697265625),
    vec2(1.1428565979003906, 4.76837158203125e-7)
);

uint read(uvec3 pos) {
  uvec3 p = uvec3(
    pos.x << 1,
    pos.y << 1,
    pos.z << 1
  );

  if (any(greaterThanEqual(p, lowerMipDims))) {
    return 0;
  }

  float slots = volumeSlabDims.x * volumeSlabDims.y * volumeSlabDims.z;
  vec2 lod = lod_defs[mipLevel-1];
  uint offset = uint(slots * lod.x);

  uint idx = offset + uint(
    p.x +
    p.y * lowerMipDims.x +
    p.z * lowerMipDims.x * lowerMipDims.y
  );

  return uint(volumeSlab[idx]) > 0 ? 1 : 0;
}

void write(uvec3 p, uint val) {
  if (any(greaterThanEqual(p, mipDims))) {
    return;
  }

  vec2 lod = lod_defs[mipLevel];
  float slots = volumeSlabDims.x * volumeSlabDims.y * volumeSlabDims.z;
  uint offset = uint(slots * lod.x);

  uint idx = offset + uint(
    p.x +
    p.y * mipDims.x +
    p.z * mipDims.x * mipDims.y
  );

  volumeSlab[idx] = uint8_t(val);
}

void main() {
  return;
  // uvec3 pos = gl_GlobalInvocationID.xyz;
  // if (any(greaterThanEqual(pos, mipDims))) {
  //   return;
  // }
  //
  // uint density = 0;
  //
  // density |= read(pos + uvec3(0, 0, 0)) != 0 ? 1<<0 : 0;
  // density |= read(pos + uvec3(1, 0, 0)) != 0 ? 1<<1 : 0;
  // density |= read(pos + uvec3(1, 1, 0)) != 0 ? 1<<2 : 0;
  // density |= read(pos + uvec3(0, 1, 0)) != 0 ? 1<<3 : 0;
  // density |= read(pos + uvec3(0, 0, 1)) != 0 ? 1<<4 : 0;
  // density |= read(pos + uvec3(1, 0, 1)) != 0 ? 1<<5 : 0;
  // density |= read(pos + uvec3(1, 1, 1)) != 0 ? 1<<6 : 0;
  // density |= read(pos + uvec3(0, 1, 1)) != 0 ? 1<<7 : 0;
  //
  // write(pos, density);
}
