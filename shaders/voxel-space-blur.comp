#version 430 core
#extension GL_NV_gpu_shader5: enable
#extension GL_ARB_bindless_texture : require
#extension GL_ARB_compute_shader: enable

#include "voxel-space.glsl"
#include "cosine-direction.glsl"

layout( local_size_x = 128, local_size_y = 8, local_size_z = 1 ) in;

layout (std430, binding=1) buffer outColorBuffer {
  vec4 out_color[];
};
layout (std430, binding=2) buffer inTerminationBuffer {
  RayTermination in_termination[];
};

layout (std430, binding=7) buffer blueNoiseBuffer {
  vec4 blueNoise[];
};


uniform uvec2 resolution;
uniform uint time;
uniform vec3 eye;
uniform vec3 dims;
uniform float debug;
uniform uint terminationBufferIdx;

bool read(ivec2 pos, out RayTermination termination) {
  if (any(lessThan(pos, ivec2(0))) || any(greaterThanEqual(pos, resolution))) {
    return false;
  }

  uint idx = (pos.x + pos.y * resolution.x) + terminationBufferIdx;
  termination = in_termination[idx];

  return true;
}

vec4 readT(ivec2 pos) {
  vec4 color = vec4(0.0);
  if (pos.x < 0 || pos.y < 0 || pos.x >= resolution.x || pos.y >= resolution.y) {
    return color;
  }

  for (uint i=1; i<=16; i++) {
    uint idx = (pos.x + pos.y * resolution.x) + (resolution.x * resolution.y * ((time + i) % 16));
    color += in_termination[idx].color;// * (1.0 * float(i) / 16.0);//((1 + float(i % 64)) / 64.0);
 }

  return color / 8;
}


void main() {

  ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
  uint idx = pos.x + pos.y * resolution.x;
  RayTermination o;
  read(pos, o);

  //out_color[idx] = vec4(in_termination[idx].position.xyz / vec3(dims), 1.0);

  out_color[idx] = in_termination[idx].color;
}

void main1() {

  ivec2 pos = ivec2(gl_GlobalInvocationID.xy);
  uint idx = pos.x + pos.y * resolution.x;
  RayTermination o;
  read(pos, o);

  out_color[idx] = mix(
    o.color,
    readT(pos),
    0.0//float(pos.x) > float(resolution.x) / 2.0 ? 1.0 : 0.0
  );

  //out_color[idx] = o.color;
}
