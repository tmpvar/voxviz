#version 430 core
#extension GL_NV_shader_buffer_load: enable
#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable

layout( local_size_x = 64, local_size_y = 4, local_size_z = 1 ) in;

uniform uint mipLevel;

#include "light-space-mips.glsl"

void main() {
  uint lowerMip = mipLevel - 1;
  // lower mip cell size
  float ls = (float(1<<(lowerMip)));
  // upper mip cell size
  float us = (float(1<<(mipLevel)));

  // get the world space position
  vec3 pos = gl_GlobalInvocationID.xyz * us;
  if (any(greaterThanEqual(pos, lightSlabDims))) {
    return;
  }

  vec4 acc = vec4(0.0);
  vec4 tmp;

  accumulate(pos + vec3( ls, 0.0, 0.0), lowerMip, 1.0, acc);
  accumulate(pos + vec3(-ls, 0.0, 0.0), lowerMip, 0.75, acc);
  accumulate(pos + vec3(0.0,  ls, 0.0), lowerMip, 0.75, acc);
  accumulate(pos + vec3(0.0, -ls, 0.0), lowerMip, 0.75, acc);
  accumulate(pos + vec3(0.0, 0.0,  ls), lowerMip, 0.75, acc);
  accumulate(pos + vec3(0.0, 0.0, -ls), lowerMip, 0.75, acc);

  accumulate(pos + vec3( ls, 0.0,  ls), lowerMip, 0.25, acc);
  accumulate(pos + vec3(-ls, 0.0,  ls), lowerMip, 0.25, acc);
  accumulate(pos + vec3(-ls, 0.0, -ls), lowerMip, 0.25, acc);
  accumulate(pos + vec3(-ls, 0.0,  ls), lowerMip, 0.25, acc);

  accumulate(pos + vec3( ls,  ls, 0.0), lowerMip, 0.25, acc);
  accumulate(pos + vec3(-ls,  ls, 0.0), lowerMip, 0.25, acc);
  accumulate(pos + vec3(-ls, -ls, 0.0), lowerMip, 0.25, acc);
  accumulate(pos + vec3( ls, -ls, 0.0), lowerMip, 0.25, acc);

  accumulate(pos + vec3( 0.0,  ls,  ls), lowerMip, 0.25, acc);
  accumulate(pos + vec3( 0.0, -ls,  ls), lowerMip, 0.25, acc);
  accumulate(pos + vec3( 0.0, -ls, -ls), lowerMip, 0.25, acc);
  accumulate(pos + vec3( 0.0,  ls, -ls), lowerMip, 0.25, acc);

  accumulate(pos + vec3(  ls,  ls,  ls), lowerMip, 0.125, acc);
  accumulate(pos + vec3( -ls,  ls,  ls), lowerMip, 0.125, acc);
  accumulate(pos + vec3( -ls, -ls,  ls), lowerMip, 0.125, acc);
  accumulate(pos + vec3( -ls, -ls, -ls), lowerMip, 0.125, acc);
  accumulate(pos + vec3( -ls,  ls, -ls), lowerMip, 0.125, acc);
  accumulate(pos + vec3(  ls,  ls, -ls), lowerMip, 0.125, acc);
  accumulate(pos + vec3(  ls, -ls, -ls), lowerMip, 0.125, acc);

  acc /= 3;

  vec4 orig;
  light_mip_get(pos, mipLevel, orig);
  light_mip_set(pos, mipLevel, max(acc, orig));

  //light_mip_set(pos, mipLevel, acc) / 2.0);
}
