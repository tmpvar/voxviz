#version 430 core
#extension GL_NV_shader_buffer_load: enable
#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable

layout( local_size_x = 32, local_size_y = 1, local_size_z = 1 ) in;

#define TAU 6.283185307179586
#define PI 3.141592653589793

uniform vec3 lightPos;
uniform vec3 lightColor;
uniform uint time;
uniform vec3 characterPos;
uniform float samples;

#include "voxel-space-mips.glsl"
#include "light-space-mips.glsl"

layout (std430) buffer blueNoiseBuffer {
  vec4 blueNoise[];
};

bool outOfBounds(vec3 p) {
  if (
    any(lessThan(p, vec3(0.0))) ||
    any(greaterThanEqual(p, vec3(lightSlabDims)))
  ) {
    return true;
  }
  return false;
}

void fillDirection(vec3 origin, vec3 dir) {
  uint8_t occlusion;
  uint steps = 256;
  float ratio = 1 / float(steps);
  float t = 0.0;
  uvec3 d = uvec3(lightSlabDims);
  float intensity = 1.0;

  for (uint i=0; i<steps; i++) {
    vec3 p = origin + dir * t;

    if (outOfBounds(p)) {
      return;
    }

    vec4 color = vec4(0.0);
    if (voxel_mip_get(p, 0, occlusion)) {
      // TODO: merge this with any existing light value
      light_mip_set(p, 0, vec4(lightColor, intensity));
      return;
    }

    t += max(1.1, t * 0.015);// 1.0;//max(0.1, t*0.1);// 16.0;// ratio * float(i) * 64;
  }
}

void main() {
  float h = samples * 0.5;
  float a = 0.495;
  uint face = gl_GlobalInvocationID.z;

  vec2 o =  (vec2(gl_GlobalInvocationID.xy) - h) / samples;

  if (true) {
    vec3 dir;
    switch (face) {
      case 0: dir = vec3( a, o.x, o.y); break;
      case 1: dir = vec3(-a, o.x, o.y); break;
      case 2: dir = vec3(o.x,  a, o.y); break;
      case 3: dir = vec3(o.x, -a, o.y); break;
      case 4: dir = vec3(o.x, o.y,  a); break;
      case 5: dir = vec3(o.x, o.y, -a); break;
    }
    fillDirection(lightPos, normalize(dir));
  } else {

    fillDirection(lightPos, normalize(vec3( a, o.x, o.y)));
    fillDirection(lightPos, normalize(vec3(-a, o.x, o.y)));
    fillDirection(lightPos, normalize(vec3(o.x,  a, o.y)));
    fillDirection(lightPos, normalize(vec3(o.x, -a, o.y)));
    fillDirection(lightPos, normalize(vec3(o.x, o.y,  a)));
    fillDirection(lightPos, normalize(vec3(o.x, o.y, -a)));
  }
}
