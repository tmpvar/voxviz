#version 430 core
#extension GL_NV_shader_buffer_load: enable
#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable

layout( local_size_x = 32, local_size_y = 8, local_size_z = 1 ) in;

#define TAU 6.283185307179586
#define PI 3.141592653589793

uniform vec3 lightPos;
uniform vec3 lightColor;
uniform uint time;
uniform vec3 characterPos;
uniform float samples;

uniform uint axis;
uniform uint start;

layout (std430) buffer blueNoiseBuffer {
  vec4 blueNoise[];
};


#include "voxel-space.glsl"
#include "voxel-space-mips.glsl"
#include "light-space-mips.glsl"
#include "cdir.glsl"

bool outOfBounds(vec3 p) {
  if (
    any(lessThan(p, vec3(0.0))) ||
    any(greaterThanEqual(p, vec3(lightSlabDims)))
  ) {
    return true;
  }
  return false;
}

void fillDirection(vec3 origin, vec3 dir) {
  uint8_t occlusion;
  uint steps = 256;
  float ratio = 1 / float(steps);
  float t = 0.0;
  uvec3 d = uvec3(lightSlabDims);
  float intensity = 1.0;

  for (uint i=0; i<steps; i++) {
    vec3 p = origin + dir * t;

    if (outOfBounds(p)) {
      return;
    }

    vec4 color = vec4(0.0);
    if (voxel_mip_get(p, 0, occlusion)) {
      // TODO: merge this with any existing light value
      light_mip_set(p, 0, vec4(lightColor, intensity));
      return;
    }

    t += max(1.1, t * 0.015);// 1.0;//max(0.1, t*0.1);// 16.0;// ratio * float(i) * 64;
  }
}

void fillDirectionEmptySpaceSkip(vec3 origin, vec3 dir) {
  uint8_t occlusion;
  uint steps = 128;
  float ratio = 1 / float(steps);
  float t = 0.0;
  uvec3 d = uvec3(lightSlabDims);
  float intensity = 1.0;

  uint mip = MAX_MIPS;
  uint minMip = 1;
  uint maxMip = MAX_MIPS;

  float dt = 1.0 / length(volumeSlabDims);
  float mipSize = (float(1<<(mip)));
  float invMipSize = 1.0 / mipSize;

  vec3 invDir = 1.0 / dir;
  vec3 prevP = origin;
  vec3 p = origin;
  for (uint i=0; i<steps; i++) {
    prevP = p;
    p = origin + dir * t;

    if (outOfBounds(p)) {
      return;
    }

    vec4 pcolor = vec4(0.0);
    // light_mip_get(p, mip, pcolor);
    // light_mip_set(p, mip, (vec4(lightColor, 1.0) + pcolor) / 2.0);


    if (voxel_mip_get(p, mip, occlusion)) {

      if (mip == minMip) {
        for (uint i=0; i<MAX_MIPS; i++) {
          light_mip_get(p, i, pcolor);
          //pcolor *= (1.0 - float(i) / float(MAX_MIPS));
          light_mip_set(p, i, (vec4(lightColor, 1.0) + pcolor) / 2.0);
        }
        // vec3 pp = prevP + dir * 0.1;
        // light_mip_get(pp, mip, pcolor);
        // light_mip_set(pp, mip, (vec4(lightColor, 1.0) + pcolor) / 2.0);
        //
        light_mip_get(p, mip, pcolor);
        light_mip_set(p, mip, (vec4(lightColor, 1.0) + pcolor) / 2.0);
        return;
      } else {
        intensity *= float(occlusion) / 255.0;
      }

      mip = max(mip - 1, minMip);
      t -= dt * 0.125;

      mipSize = (float(1<<(mip)));
      invMipSize = 1.0 / mipSize;
      continue;
    }
    else if (mip < maxMip && !voxel_mip_get(p, min(mip + 1, maxMip), occlusion)) {
      mip = min(maxMip, mip+1);
      mipSize = (float(1<<(mip)));
      invMipSize = 1.0 / mipSize;
      t += dt * 0.125;
    }

    vec3 deltas = (step(0.0, dir) - fract(p * invMipSize)) * invDir;
    dt = max(mincomp(deltas), 0.0001) * mipSize;
    t += max(0.1,t * 0.002);
    t += dt;
  }
}

void main() {
  uvec2 o  = gl_GlobalInvocationID.xy - 1;

  vec3 pos;
  switch (axis) {
    case 0: pos = vec3(start * lightSlabDims.x, o.x, o.y); break;
    case 1: pos = vec3(o.x, start * lightSlabDims.y, o.y); break;
    case 2: pos = vec3(o.x, o.y, start * lightSlabDims.z); break;
  }

  // get at the center of the voxel
  vec3 dir;
  vec3 target = lightPos;
  pos += (start == 0) ? 0.5 : -0.5;

  if (false) {
    for (uint i=0; i<4; i++) {
      target = lightPos + sampleBlueNoise(o.x * o.y * i * (axis + 1) + start) * 3.0;
      vec3 p = pos;
      dir = normalize(p - target);
      fillDirectionEmptySpaceSkip(target, dir);
    }
  } else {
    dir = normalize(pos - target);
    fillDirectionEmptySpaceSkip(target, dir);
  }
  // vec3 dir = normalize(pos - lightPos);
  // fillDirectionEmptySpaceSkip(lightPos, dir);
  //
  //
  // dir = normalize(pos - lightPos);
  // fillDirectionEmptySpaceSkip(lightPos, dir);
}
