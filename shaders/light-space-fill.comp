#version 430 core
#extension GL_NV_shader_buffer_load: enable
#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable

layout( local_size_x = 32, local_size_y = 1, local_size_z = 1 ) in;

#define TAU 6.283185307179586
#define PI 3.141592653589793

uniform vec3 lightPos;
uniform vec3 lightColor;
uniform uint time;
uniform vec3 characterPos;
uniform float samples;

#include "voxel-space.glsl"
#include "voxel-space-mips.glsl"
#include "light-space-mips.glsl"

layout (std430) buffer blueNoiseBuffer {
  vec4 blueNoise[];
};

bool outOfBounds(vec3 p) {
  if (
    any(lessThan(p, vec3(0.0))) ||
    any(greaterThanEqual(p, vec3(lightSlabDims)))
  ) {
    return true;
  }
  return false;
}

void fillDirection(vec3 origin, vec3 dir) {
  uint8_t occlusion;
  uint steps = 256;
  float ratio = 1 / float(steps);
  float t = 0.0;
  uvec3 d = uvec3(lightSlabDims);
  float intensity = 1.0;

  for (uint i=0; i<steps; i++) {
    vec3 p = origin + dir * t;

    if (outOfBounds(p)) {
      return;
    }

    vec4 color = vec4(0.0);
    if (voxel_mip_get(p, 0, occlusion)) {
      // TODO: merge this with any existing light value
      light_mip_set(p, 0, vec4(lightColor, intensity));
      return;
    }

    t += max(1.1, t * 0.015);// 1.0;//max(0.1, t*0.1);// 16.0;// ratio * float(i) * 64;
  }
}

void fillDirectionEmptySpaceSkip(vec3 origin, vec3 dir) {
  uint8_t occlusion;
  uint steps = 256;
  float ratio = 1 / float(steps);
  float t = 0.0;
  uvec3 d = uvec3(lightSlabDims);
  float intensity = 1.0;

  uint mip = 0;
  uint minMip = 0;
  uint maxMip = MAX_MIPS;

  float dt = 1.0 / length(volumeSlabDims);
  float mipSize = (float(1<<(mip)));
  float invMipSize = 1.0 / mipSize;

  vec3 invDir = 1.0 / dir;

  for (uint i=0; i<steps; i++) {
    vec3 p = origin + dir * t;

    if (outOfBounds(p)) {
      return;
    }

    if (voxel_mip_get(p, mip, occlusion)) {
      vec4 pcolor = vec4(0.0);

      for (uint j=mip; j<MAX_MIPS; j++) {
        pcolor = vec4(0.0);
        light_mip_get(p, mip, pcolor);
        light_mip_set(p, mip, (vec4(lightColor, intensity) + pcolor) / 2.0);
      }

      if (mip == minMip) {

        return;
      }

      mip = max(mip - 1, minMip);
      t -= dt * 0.00125;

      mipSize = (float(1<<(mip)));
      invMipSize = 1.0 / mipSize;
      continue;
    }
    else if (mip < maxMip && !voxel_mip_get(p, min(mip + 1, maxMip), occlusion)) {
      mip = min(maxMip, mip+1);
      mipSize = (float(1<<(mip)));
      invMipSize = 1.0 / mipSize;
      t += dt * 0.125;
    }

    vec3 deltas = (step(0.0, dir) - fract(p * invMipSize)) * invDir;
    dt = max(mincomp(deltas), 0.0001) * mipSize;
    t += max(1.0,t * 0.001);
    t += dt;

  }
}

void main() {
  float h = samples * 0.5;
  float a = 0.495;
  uint face = gl_GlobalInvocationID.z;

  vec2 o =  (vec2(gl_GlobalInvocationID.xy) - h) / samples;

  if (true) {
    vec3 dir;
    switch (face) {
      case 0: dir = vec3( a, o.x, o.y); break;
      case 1: dir = vec3(-a, o.x, o.y); break;
      case 2: dir = vec3(o.x,  a, o.y); break;
      case 3: dir = vec3(o.x, -a, o.y); break;
      case 4: dir = vec3(o.x, o.y,  a); break;
      case 5: dir = vec3(o.x, o.y, -a); break;
    }
    fillDirectionEmptySpaceSkip(lightPos, normalize(dir));
  } else {

    fillDirection(lightPos, normalize(vec3( a, o.x, o.y)));
    fillDirection(lightPos, normalize(vec3(-a, o.x, o.y)));
    fillDirection(lightPos, normalize(vec3(o.x,  a, o.y)));
    fillDirection(lightPos, normalize(vec3(o.x, -a, o.y)));
    fillDirection(lightPos, normalize(vec3(o.x, o.y,  a)));
    fillDirection(lightPos, normalize(vec3(o.x, o.y, -a)));
  }
}
