#version 430 core
#extension GL_NV_shader_buffer_load: enable
#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable

layout( local_size_x = 1, local_size_y = 1, local_size_z = 1 ) in;

//uniform vec3 lightPos;
uniform vec3 lightColor;
uniform vec3 dims;
uniform uint time;

// uses bindings 1-7 and requires `dims`
#include "voxel-space-mips.glsl"
#include "dda-cursor.glsl"

layout (std430, binding=8) buffer lightSlab {
  vec4 light[];
};

#define DIR_COUNT 8
const vec3 dirs[DIR_COUNT] = {
  vec3(1.0, 0.0, 0.0),
  vec3(1.0, 1.0, 0.0),
  vec3(1.0, -1.0, 0.0),
  vec3(0.0, 1.0, 0.0),

  vec3(-1.0, 0.0, 0.0),
  vec3(-1.0, 1.0, 0.0),
  vec3(-1.0, -1.0, 0.0),
  vec3(0.0, -1.0, 0.0),
};

void main() {
  uint dir_idx = gl_GlobalInvocationID.x;
  if (dir_idx >= DIR_COUNT) {
    return;
  }
  uvec3 d = uvec3(dims);
  vec3 lightPos = vec3(
      64,
      64 + sin(float(time) / 100.0) * 5,
      0
  );

  vec3 mapPos = vec3(lightPos);
  vec3 dir = normalize(dirs[dir_idx]);
  DDACursor c = dda_cursor_create(
    lightPos + 0.5 + dir,
    dir
  );

  uint8_t noop;
  vec3 found_normal;
  for (uint i=0; i<512; i++) {
    vec3 p = lightPos + dir * float(i);
    if (
      any(lessThan(p, vec3(0.0))) ||
      any(greaterThanEqual(p, vec3(dims)))
    ) {
      break;
    }

    uvec3 up = uvec3(p);
    uint idx = (up.x + up.y * d.x + up.z * d.x * d.y);

    if (voxel_get(up, noop)) {
      light[idx] = vec4(0.0, 1.0, 0.0, 1.0);
      return;
    }

    light[idx] = vec4(lightColor, 1.0);
    dda_cursor_step(c, found_normal);
  }
}
