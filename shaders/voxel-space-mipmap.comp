#version 430 core
#extension GL_NV_shader_buffer_load: enable
#extension GL_ARB_compute_shader: enable
#extension GL_NV_gpu_shader5: enable

layout( local_size_x = 64, local_size_y = 4, local_size_z = 1 ) in;

layout (std430) buffer volumeSlabBuffer {
  uint8_t volumeSlab[];
};
uniform vec3 volumeSlabDims;

uniform uvec3 mipDims;
uniform uvec3 lowerMipDims;
uniform uint mipLevel;

#include "mips.glsl"

uint read(uvec3 pos, uint offset) {
  uvec3 p = pos << 1;

  if (any(greaterThanEqual(p, lowerMipDims))) {
    return 0;
  }

  uint idx = offset + uint(
    p.x +
    p.y * lowerMipDims.x +
    p.z * lowerMipDims.x * lowerMipDims.y
  );

  return uint(volumeSlab[idx]) > 0 ? 1 : 0;
}

void write(uvec3 p, uint val) {
  vec2 lod = lod_defs[mipLevel];
  float slots = volumeSlabDims.x * volumeSlabDims.y * volumeSlabDims.z;
  uint offset = uint(slots * lod.x);

  uint idx = offset + uint(
    p.x +
    p.y * mipDims.x +
    p.z * mipDims.x * mipDims.y
  );

  volumeSlab[idx] = uint8_t(val);
}

void main() {
  uvec3 pos = gl_GlobalInvocationID.xyz;
  if (any(greaterThanEqual(pos, mipDims))) {
    return;
  }

  uint density = 0;
  float slots = volumeSlabDims.x * volumeSlabDims.y * volumeSlabDims.z;
  vec2 lod = lod_defs[mipLevel-1];
  uint offset = uint(slots * lod.x);

  density |= read(pos + uvec3(0, 0, 0), offset) != 0 ? 1<<0 : 0;
  density |= read(pos + uvec3(1, 0, 0), offset) != 0 ? 1<<1 : 0;
  density |= read(pos + uvec3(1, 1, 0), offset) != 0 ? 1<<2 : 0;
  density |= read(pos + uvec3(0, 1, 0), offset) != 0 ? 1<<3 : 0;
  density |= read(pos + uvec3(0, 0, 1), offset) != 0 ? 1<<4 : 0;
  density |= read(pos + uvec3(1, 0, 1), offset) != 0 ? 1<<5 : 0;
  density |= read(pos + uvec3(1, 1, 1), offset) != 0 ? 1<<6 : 0;
  density |= read(pos + uvec3(0, 1, 1), offset) != 0 ? 1<<7 : 0;

  write(pos, density);
}
